<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文转载自 LearnKu 社区作者 Dennis_Ritchie原文地址：https:&#x2F;&#x2F;learnku.com&#x2F;articles&#x2F;36471  我为什么会写这篇文章？当初作为编程小白的我，刚刚从事后台工作，觉得http是个很牛逼的东西，然而后面随着自己深入学习并实践之后，觉得原来和我所想的天壤之别，没大家想象的那么复杂，仅仅是个协议嘛！。后面学习的东西多了，慢慢的就淡定了。今天这里之所以要讲">
<meta property="og:type" content="article">
<meta property="og:title" content="老司机带你用 PHP 实现 Websocket 协议">
<meta property="og:url" content="http://example.com/2021/01/01/%E8%80%81%E5%8F%B8%E6%9C%BA%E5%B8%A6%E4%BD%A0%E7%94%A8%20PHP%20%E5%AE%9E%E7%8E%B0%20Websocket%20%E5%8D%8F%E8%AE%AE/index.html">
<meta property="og:site_name" content="Airy">
<meta property="og:description" content="本文转载自 LearnKu 社区作者 Dennis_Ritchie原文地址：https:&#x2F;&#x2F;learnku.com&#x2F;articles&#x2F;36471  我为什么会写这篇文章？当初作为编程小白的我，刚刚从事后台工作，觉得http是个很牛逼的东西，然而后面随着自己深入学习并实践之后，觉得原来和我所想的天壤之别，没大家想象的那么复杂，仅仅是个协议嘛！。后面学习的东西多了，慢慢的就淡定了。今天这里之所以要讲">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201911/14/39566/zmdoyPJwXj.gif!large">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201911/14/39566/EHlpiJt4cR.png!large">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201911/14/39566/9QF4bZnYRn.png!large">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201911/14/39566/1MonQr8KIt.png!large">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201911/14/39566/qsD9KBkIhy.png!large">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201911/14/39566/SMvw44AOCU.gif!large">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201911/14/39566/lhMpKOIiOt.png!large">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201911/14/39566/W54kBYxWRv.png!large">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201911/14/39566/ptc8PpYw6z.gif!large">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201911/14/39566/oe9rbwGjfY.gif!large">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201911/14/39566/QI31dK1krp.png!large">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201911/14/39566/uuKoGNPhoH.png!large">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201911/14/39566/4NsDk0FZek.png!large">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/201911/22/39566/JUOFyjuSgg.png!large">
<meta property="article:published_time" content="2021-01-01T07:56:16.526Z">
<meta property="article:modified_time" content="2021-01-01T09:18:18.712Z">
<meta property="article:author" content="Airy">
<meta property="article:tag" content="socket">
<meta property="article:tag" content="php">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.learnku.com/uploads/images/201911/14/39566/zmdoyPJwXj.gif!large">

<link rel="canonical" href="http://example.com/2021/01/01/%E8%80%81%E5%8F%B8%E6%9C%BA%E5%B8%A6%E4%BD%A0%E7%94%A8%20PHP%20%E5%AE%9E%E7%8E%B0%20Websocket%20%E5%8D%8F%E8%AE%AE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>老司机带你用 PHP 实现 Websocket 协议 | Airy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Airy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/01/%E8%80%81%E5%8F%B8%E6%9C%BA%E5%B8%A6%E4%BD%A0%E7%94%A8%20PHP%20%E5%AE%9E%E7%8E%B0%20Websocket%20%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.gif">
      <meta itemprop="name" content="Airy">
      <meta itemprop="description" content="令行禁止">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          老司机带你用 PHP 实现 Websocket 协议
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-01 15:56:16 / 修改时间：17:18:18" itemprop="dateCreated datePublished" datetime="2021-01-01T15:56:16+08:00">2021-01-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/socket/" itemprop="url" rel="index"><span itemprop="name">socket</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>本文转载自 LearnKu 社区作者 Dennis_Ritchie<br>原文地址：<a target="_blank" rel="noopener" href="https://learnku.com/articles/36471">https://learnku.com/articles/36471</a></p>
</blockquote>
<h2 id="我为什么会写这篇文章？"><a href="#我为什么会写这篇文章？" class="headerlink" title="我为什么会写这篇文章？"></a>我为什么会写这篇文章？</h2><p>当初作为编程小白的我，刚刚从事后台工作，觉得http是个很牛逼的东西，然而后面随着自己深入学习并实践之后，觉得原来和我所想的天壤之别，没大家想象的那么复杂，仅仅是个协议嘛！。后面学习的东西多了，慢慢的就淡定了。今天这里之所以要讲websocket，而不是其它的协议，从某种意义上来说（请允许我装个逼），更能说明问题，如果你把websocket都搞懂了，那么http对于你来说，简直就是雕虫小技啊，关于websocket的代码，以前我使用C和C++写的，但是为了PHP的coder（PHP是世界上最好的语言）能明白，我用PHP重新写了一遍，但是个精简版，对于我们彻底搞懂websocket，理解它的精华所在，已经足够了。代码我已经上传到了码云（<a target="_blank" rel="noopener" href="https://gitee.com/obamajs/php-websocket-base-implemention">php-websocket-base-implemention</a>），<strong>请大家一定一定要下载下来，并亲自运行</strong>，<strong>实践才是检验真理的唯一标准啊</strong>，代码是完全可以运行的，如果运行的时候有障碍，请联系我。该博文差不多修修改改了3天（幸亏公司里面事不多），尽可能的给大家讲清楚。突然感觉，写文章好累啊，这都不重要，希望大家能够看懂，不然我写的就没啥用了。更希望大家遇到不懂的，提出疑问。写完之后，我再次审查了当前博文的内容，修改了一些拼写错误，可能还会有一些漏网之鱼，希望大家多多指正。</p>
<h2 id="文章链接"><a href="#文章链接" class="headerlink" title="文章链接"></a>文章链接</h2><p><a target="_blank" rel="noopener" href="https://learnku.com/articles/36655">PHP实现Base64编码</a></p>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在阅读这篇博文之前，需要大家有一定的基础知识储备，下面我会给大家列出来，先装一下逼</p>
<p><img src="https://cdn.learnku.com/uploads/images/201911/14/39566/zmdoyPJwXj.gif!large"></p>
<h3 id="socket基础"><a href="#socket基础" class="headerlink" title="socket基础"></a>socket基础</h3><p>基本的socket编程技能，如果你不知道，也不要慌，以防万一，我已经为大家准备好了，请参考<a target="_blank" rel="noopener" href="https://learnku.com/articles/36363">PHP 编写基本的 Socket 程序</a></p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>因为在一般的php编程当中，很少遇到会有位操作的情况，所以遗忘和不熟悉就理所当然了，我们可以参考<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/language.operators.bitwise.php">php官方文档</a>，但是我还是要讲一点，<strong>异或</strong>（^）操作，请看下面，这个结论很重要，请大家一定要记住，切记切记，重要的事情讲三遍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a ^ b &#x3D; c  可以推导出 c ^ b &#x3D; a</span><br></pre></td></tr></table></figure>
<h3 id="二进制数据和文本数据"><a href="#二进制数据和文本数据" class="headerlink" title="二进制数据和文本数据"></a>二进制数据和文本数据</h3><p>是不是有的时候打开一个文件显示乱码，就像下面这样</p>
<p><img src="https://cdn.learnku.com/uploads/images/201911/14/39566/EHlpiJt4cR.png!large" alt="老司机带你实现Websocket协议"><br>因为你打开的是二进制数据，<strong>二进制数据和文本数据的最根本的区别就是在数字的存储</strong>，举个例子，假设数字 int a=100，我们假设它会占用4个字节的空间，但是注意了，如果将它作为字符串存储，结果只需要三个字节（每一位占用一个字节），文本软件不管这些啊，都当做文本，显示的内容就成了乱码了。因此如果某个二进制文件不是你写入的，想要解析它的内容，不太现实。</p>
<h3 id="大端序和小端序，网络字节序"><a href="#大端序和小端序，网络字节序" class="headerlink" title="大端序和小端序，网络字节序"></a>大端序和小端序，网络字节序</h3><p>之所以存在这种说法，是因为不同的CPU架构下，<strong>多字节数据在内容中的存储格式有所不同</strong>，这里我们以int（假设为4字节）数据m（数据采用16进制格式）为例，<strong>m=0x12345678</strong>，来进行说明，请仔细体会a，b，c，d的内存地址依次增大。</p>
<p><img src="https://cdn.learnku.com/uploads/images/201911/14/39566/9QF4bZnYRn.png!large" alt="老司机带你实现Websocket协议"></p>
<ul>
<li>小端序，低字节存储在低位地址，高字节存储在高位地址，什么意思呢？此时0x78存储在a，0x56存储b，0x34存储c，0x12存储d。</li>
<li>大端序，高位字节存储在低位，低位字节存储在高位，此时0x78存储在d，0x56存储c，0x34存储b，0x12存储a。</li>
<li>网络字节序，<strong>网络字节序是大端字节序</strong>，这已经成为标准。</li>
</ul>
<p>从上面的分析可以知道，<strong>当我们从网络数据中解析多字节数据时，是一定要考虑字节的顺序的</strong>，这就是我这里着重强调的原因。</p>
<h2 id="协议的诞生"><a href="#协议的诞生" class="headerlink" title="协议的诞生"></a>协议的诞生</h2><p>Websocket协议如今应用非常广泛，，造成这一现象的很大原因，在于http协议的短暂性，客户端和服务器之间每一次的请求应答都需要建立TCP三次握手，这对于流量很大的服务器来说是非常恐怖的（系统级资源），所以这个时候websocket诞生了，具体的诞生日期是哪一年已经不得而知了，但是真正的标准化时间是在2011年，由IETF正式完成，具体请参考<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6455">RFC6455</a>。</p>
<h2 id="协议工作流程"><a href="#协议工作流程" class="headerlink" title="协议工作流程"></a>协议工作流程</h2><p>下面有一张图，可以说明这一点，该图片来自Google，</p>
<p><img src="https://cdn.learnku.com/uploads/images/201911/14/39566/1MonQr8KIt.png!large" alt="老司机带你实现Websocket协议"></p>
<p><strong>websocket协议和http协议都属于应用层协议（在TCP/IP之上）</strong>，但是websocket协议相对于http协议多了一个<strong>握手</strong>（这个握手不是平时所说的tcp三次握手啊，注意了）的过程，从上面的图可以很清晰的看出来，http是是一个文本协议，但是websocket有所不同，它有自己严格的字节格式，稍后会讲到。</p>
<h2 id="数据包格式"><a href="#数据包格式" class="headerlink" title="数据包格式"></a>数据包格式</h2><p><img src="https://cdn.learnku.com/uploads/images/201911/14/39566/qsD9KBkIhy.png!large" alt="老司机带你实现Websocket协议"></p>
<p>看到这张图，有没有想到TCP、IP的协议，不过这个图相对来说要简单一些，后面我会给大家详细的讲解每一部分的含义，慢慢来，不要慌，慌个啥子额。</p>
<p><img src="https://cdn.learnku.com/uploads/images/201911/14/39566/SMvw44AOCU.gif!large"></p>
<h2 id="协议流程概览"><a href="#协议流程概览" class="headerlink" title="协议流程概览"></a>协议流程概览</h2><p>该协议由2部分组成，<strong>握手</strong>和<strong>数据传输</strong>，握手部分并不复杂，并且<strong>握手是建立在HTTP协议之上</strong>的，下面我们先来看一下协议的握手过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ&#x3D;&#x3D;</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>
<p>服务器响应如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">   Upgrade: websocket</span><br><span class="line">   Connection: Upgrade</span><br><span class="line">   Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo&#x3D;</span><br><span class="line">   Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>
<p>无论是请求或者是响应包，头部字段的顺序是没有要求的，这其中有些字段相信大家都非常熟悉了，就算不熟悉，百度一下，还是很容易搞清楚的，我们来仔细的讨论一下Websocket所特有的一些字段：</p>
<h4 id="Upgrade字段"><a href="#Upgrade字段" class="headerlink" title="Upgrade字段"></a>Upgrade字段</h4><p>这个字段表示需要升级到的协议，这个字段是必须的，并且它的值必须是websocket。</p>
<h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>这个字段表示需要升级协议，也是必须的，它的值必须是Upgrade。</p>
<h4 id="Sec-WebSocket-Key和Sec-WebSocket-Accept"><a href="#Sec-WebSocket-Key和Sec-WebSocket-Accept" class="headerlink" title="Sec-WebSocket-Key和Sec-WebSocket-Accept"></a>Sec-WebSocket-Key和Sec-WebSocket-Accept</h4><p>这个是用来客户端和服务器握手使用的，必须传递，因为服务器会使用这个值进行一定的转换然后回传给客户端，客户端再检查这个值，<br>是否和自己计算的值一样，如果不一样，那么客户端会认为，服务端是有问题的，那么结果只能是连接失败了。在介绍具体的操作之前，我们还需要介绍一个常量GUID，它的值为258EAFA5-E914-47DA-95CA-C5AB0DC85B11，这个值是固定的，任何的Websocket服务器和客户端（包括浏览器）必须定义这个值。现在我们重点来看一下这个字段，假如客户端传递的值为 dGhlIHNhbXBsZSBub25jZQ==，那么用PHP代码来表示的话，就会是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$GUID &#x3D; &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;;</span><br><span class="line">$sec_websocket_key &#x3D; &quot;dGhlIHNhbXBsZSBub25jZQ&#x3D;&#x3D;&quot;;</span><br><span class="line">$result &#x3D; base64_encode(sha1($sec_websocket_key . $GUID));</span><br></pre></td></tr></table></figure>
<p>这个计算出的$result值最终会被回传给客户端的http响应头Sec-WebSocket-Accept，客户端会验证这个值，这个就是客户端的事了。</p>
<h4 id="Sec-WebSocket-Version"><a href="#Sec-WebSocket-Version" class="headerlink" title="Sec-WebSocket-Version"></a>Sec-WebSocket-Version</h4><p>websocket协议的版本号，根据<strong>RFC6455</strong>的文档，我们知道，这个值必须是13,其它的任何值都不行，下面是它的描述：</p>
<blockquote>
<p>The request MUST include a header field with the name |Sec-WebSocket-Version|.  The value of this header field MUST be 13.<br>NOTE: Although draft versions of this document (-09, -10, -11,and -12) were posted (they were mostly comprised of editorial changes and clarifications and not changes to the wire protocol), values 9, 10, 11, and 12 were not used as valid values for Sec-WebSocket-Version.  These values were reserved in the IANA registry but were not and will not be used.</p>
</blockquote>
<h4 id="Sec-WebSocket-Protocol"><a href="#Sec-WebSocket-Protocol" class="headerlink" title="Sec-WebSocket-Protocol"></a>Sec-WebSocket-Protocol</h4><p>选择websocket所使用的子协议，这个字段不是必须的，取决于具体的实现，如果你使用的是Google浏览器的话，那么这个值是不会传递的。</p>
<h2 id="握手阶段"><a href="#握手阶段" class="headerlink" title="握手阶段"></a>握手阶段</h2><p>在讲解完了Websocket主要的http头部字段之后，我们来看一下服务端的检查代码，这里我把实例程序中的代码贴出来，给大家分析一哈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * @param $client_socket_handle</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private function shakehand($client_socket_handle)</span><br><span class="line">    &#123;</span><br><span class="line">        if (socket_recv($client_socket_handle, $buffer, 1000, 0) &lt; 0) &#123;</span><br><span class="line">            throw new Exception(socket_strerror(socket_last_error($this-&gt;socket_handle)));</span><br><span class="line">        &#125;</span><br><span class="line">        while (1) &#123;</span><br><span class="line">            if (preg_match(&quot;&#x2F;([^\r]+)\r\n&#x2F;&quot;, $buffer, $match) &gt; 0) &#123;</span><br><span class="line">                $content &#x3D; $match[1];</span><br><span class="line">                if (strncmp($content, &quot;Sec-WebSocket-Key&quot;, strlen(&quot;Sec-WebSocket-Key&quot;)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    $this-&gt;websocket_key &#x3D; trim(substr($content, strlen(&quot;Sec-WebSocket-Key:&quot;)), &quot; \r\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                $buffer &#x3D; substr($buffer, strlen($content) + 2);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;响应客户端</span><br><span class="line">        $this-&gt;writeToSocket($client_socket_handle, &quot;HTTP&#x2F;1.1 101 Switching Protocol\r\n&quot;);</span><br><span class="line">        $this-&gt;writeToSocket($client_socket_handle, &quot;Upgrade: websocket\r\n&quot;);</span><br><span class="line">        $this-&gt;writeToSocket($client_socket_handle, &quot;Connection: upgrade\r\n&quot;);</span><br><span class="line">        $this-&gt;writeToSocket($client_socket_handle, &quot;Sec-WebSocket-Accept:&quot; . $this-&gt;calculateResponseKey() . &quot;\r\n&quot;);</span><br><span class="line">        $this-&gt;writeToSocket($client_socket_handle, &quot;Sec-WebSocket-Version: 13\r\n\r\n&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先我们从客户端socket中读取1000字节的内容，这1000的字节足以读出所有的头部了（但是在企业级代码中，我们不能这么写，我们永远不能假设整个http头部有多大，在这片博文中，我们为了突出问题的重点，简化了很多代码，但是你放心，对我们来说，丝毫没有影响，socket_recv请参考我上面所说的），接下来的while循环遍历我们读取到的内容，要看懂循环里面的代码，我们有必要提下http协议的格式了，看下图</p>
<p><img src="https://cdn.learnku.com/uploads/images/201911/14/39566/lhMpKOIiOt.png!large" alt="老司机带你实现Websocket协议"><br>我觉得上面的图片，已经足以描述http协议的格式了，如果你还不懂，没关系，给大家推荐一篇来自简书的博文（<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8fe93a14754c">HTTP协议格式详解</a>），现在对于我们来说，最关心的是当前请求的Sec-WebSocket-Key头部，因为这个值需要返回给客户端，获取到这个值之后，我们把它存储在当前对象中。紧接着我们需要回应客户端吧，如果你不知道它的格式，我稍微讲一下：</p>
<p><img src="https://cdn.learnku.com/uploads/images/201911/14/39566/W54kBYxWRv.png!large" alt="老司机带你实现Websocket协议"></p>
<p><strong>对于websocket握手来说，如果服务端同意客户端的连接的话，那么返回的状态码必须是101</strong> ，至于后面的文本，不一定得是 Switching Protocol，只是别人都这么传，那就这么传了。其次，Upgrade: websocket,Connection: upgrade还有Sec-WebSocket-Version: 13，必须传递给客户端，这个是固定的，应该没有啥难度吧，另外的，Sec-WebSocket-Accept我们前面已经说了，它的计算代码，我上面已经贴出来了，这个计算方式也是固定的，<strong>千万不要忘记每一行后面得有\r\n啊，最后一行后面得有两个\r\n</strong>。</p>
<h2 id="分析数据协议"><a href="#分析数据协议" class="headerlink" title="分析数据协议"></a>分析数据协议</h2><p>看了上面握手的代码之后，是不是觉得自己要上天了，感觉真是太简单了？？骚年，醒醒，醒醒。哈哈，真实太年轻了，年轻就是好</p>
<p><img src="https://cdn.learnku.com/uploads/images/201911/14/39566/ptc8PpYw6z.gif!large"></p>
<p>看到我上面贴出来的websocket数据包格式了么，是时候解开它面纱的时候了，这部分可能有点儿难度，不要怕，有我在。下面我来来个<strong>原子级别</strong>的分析。</p>
<h4 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h4><p>FIN位，也是整个片段的第一个字节的最高位，他只能是0或者是1，这个位的作用只有一个，如果它为1，表示这个片段是整个消息的最后一个片段，如果是0，表示这个片段之后，还有其它的片段。是不是听着直接懵逼了，啥是 片段？啥是 消息？非常好，看来我装逼的时候已经来临了，废话不多说。为了搞清楚这几个概念，代码为敬</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(new WebSocket()).send(&quot;我是奥巴马&quot;);</span><br></pre></td></tr></table></figure>
<p>这是一段<strong>JAVASCRIPT</strong>代码，send函数的参数就是一条消息，非常短，但是注意了，我们不能假设任何时间，任何地点，都这么短，当它变得很长的时候，客户端就有可能对它进行切割，比如，我有一个字符串，大小为4M，我把它分为4个1M的字符串，那么每一个1M的字符串，就只能成为一个片段，每个片段独立发送，四个片段组合在一起形成了一条消息，每一个片段的格式都是固定的，格式和上面的贴图是一样的，按照刚才说的，前面的三个片段，FIN都是0，第四个才是1，清楚了么？So easy!!</p>
<h4 id="RSV1-RSV2-RSV3"><a href="#RSV1-RSV2-RSV3" class="headerlink" title="RSV1,RSV2,RSV3"></a>RSV1,RSV2,RSV3</h4><p>这三位是保留给扩展使用的，基本不会用到，反正我没用到，所以我们可以把它们当做空气就行，永远设置为0，就是这么果断。</p>
<h4 id="opcode"><a href="#opcode" class="headerlink" title="opcode"></a>opcode</h4><p>opcode顾名思义就是操作码，占用第一个字节的低四位，所以opcode可以代表16种不同的值。你是不是想问，opcode是用来干嘛的？<br>opcode是用 来解析当前片段的载荷（携带的数据）的，具体的后面会再次说明。</p>
<ul>
<li>0x00，表示当前片段是连续片段，这是啥意思呢？还记得上面讨论FIN的时候，一条消息被分割成多条片段？如果当前片段不是第一个，那么opcode必须设置为0。</li>
<li>0x01，表示当前片段所携带的数据是文本数据（记得最开始说的文本数据和二进制数据的区别？？），如果有多个片段的话，只需要在第一个片段设置该值，属于同一条消息中后面的片段，只需要设置为0即可。</li>
<li>0x02，表示当前片段所携带的数据是二进制数据，如果有多个片段的话，只需要在第一个片段设置该值，属于同一条消息中后面的片段，只需要设置为0即可。</li>
<li>0x03-0x07，保留给将来使用，也就是说暂时还没用到。</li>
<li>0x08，表示关闭websocket连接，这个后面我会再一次讲到，先放着</li>
<li>0x09，发送Ping片段，说白了，它主要是用来检测远程端点是否还存活，我想检查我的对象是不是已经死了，但是这个片段可以携带数据，如果端点的一方发送了Ping，那么接受方，必须返回Pong片段，用中国人的话来说，就是礼尚往来嘛。</li>
<li>0xA，发送Pong，用以回复Ping，是不是很简单？</li>
<li>0xB-F，保留给将来使用，也就是说暂时还没用到。</li>
</ul>
<h4 id="MASK"><a href="#MASK" class="headerlink" title="MASK"></a>MASK</h4><p>表示当前片段所携带的数据是否经过加密，位置为第二个字节的最高位，总共1位，它的值不是你想设置就设置的啊，RFC6455 明确规定，所有从客户端发送给服务器的数据必须加密，所以mask的值必须是1。还有，所有从服务器发往客户端的数据，一定不能加密，所以呢，mask必须为0，就是这么简单粗暴。</p>
<h4 id="Payload-Length"><a href="#Payload-Length" class="headerlink" title="Payload Length"></a>Payload Length</h4><p>这部分是用来定义负载数据的长度的，总共7位，所以最大值为127，就这么简单？哼哼，不会的。</p>
<ul>
<li>payload_length&lt;=125，此时数据的长度就是payload_length的大小。</li>
<li>payload_length=126，<strong>那么紧接着payload_length的2个字节，就用来表示数据的大小</strong>，所以当数据大小大于125，小于65535的时候，payload_length设置为126，后面分析代码的时候，我会再次讲到。</li>
<li>payload_length=127，也就是payload_length取最大值，<strong>那么紧接着payload_length的8个字节，就用来表示数据的大小</strong>，此可以表示的数据可就相当大了，后面分析代码的时候，我会再次讲到。</li>
</ul>
<h4 id="Mask-key"><a href="#Mask-key" class="headerlink" title="Mask key"></a>Mask key</h4><p>它的位置紧接着数据长度的后面，大小为0或者是4个字节。前面分析了mask的作用，如果mask为1的话，数据需要加密，此时mask key占用4个字节，否则长度为0，至于mask key如何用来解密数据的，后面会再次讲到。</p>
<h4 id="payload-data"><a href="#payload-data" class="headerlink" title="payload data"></a>payload data</h4><p>这里就是我们从客户端接收到的数据，不过它是经过加密的，“我是奥巴马”，之前payload_length的长度，就是经过加密之后的数据的长度，而不是原始数据的长度。</p>
<p>讲解完上面的内容之后，我们可以开始分析如何用php来解析Websocket消息片段了。</p>
<p><img src="https://cdn.learnku.com/uploads/images/201911/14/39566/oe9rbwGjfY.gif!large"></p>
<h2 id="解析数据包"><a href="#解析数据包" class="headerlink" title="解析数据包"></a>解析数据包</h2><p>这篇博文的开头我就说过了，当前的websocket实现会专注于websocket最为精华，最困难的部分，所以会忽略掉一些内容，如果你理解了下面讲的内容，其余的一些细枝末节都不是问题。</p>
<h4 id="计算数据的长度"><a href="#计算数据的长度" class="headerlink" title="计算数据的长度"></a>计算数据的长度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;等待客户端新传输的数据</span><br><span class="line">    if (!socket_recv($client_socket_handle, $buffer, 1000, 0)) &#123;</span><br><span class="line">        throw new Exception(socket_strerror(socket_last_error($client_socket_handle)));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;解析消息的长度</span><br><span class="line">    $payload_length &#x3D; ord($buffer[1]) &amp; 0x7f;&#x2F;&#x2F;第二个字符的低7位</span><br><span class="line">    if ($payload_length &gt;&#x3D; 0 &amp;&amp; $payload_length &lt; 125) &#123;</span><br><span class="line">        $this-&gt;current_message_length &#x3D; $payload_length;</span><br><span class="line">        $payload_type &#x3D; 1;</span><br><span class="line">        echo $payload_length . &quot;\n&quot;;</span><br><span class="line">    &#125; else if ($payload_length &#x3D;&#x3D; 126) &#123;</span><br><span class="line">        $payload_type &#x3D; 2;</span><br><span class="line">        $this-&gt;current_message_length &#x3D; ((ord($buffer[2]) &amp; 0xff) &lt;&lt; 8) | (ord($buffer[3]) &amp; 0xff);</span><br><span class="line">        echo $this-&gt;current_message_length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $payload_type &#x3D; 3;</span><br><span class="line">        $this-&gt;current_message_length &#x3D;</span><br><span class="line">            (ord($buffer[2]) &lt;&lt; 56)</span><br><span class="line">            | (ord($buffer[3]) &lt;&lt; 48)</span><br><span class="line">            | (ord($buffer[4]) &lt;&lt; 40)</span><br><span class="line">            | (ord($buffer[5]) &lt;&lt; 32)</span><br><span class="line">            | (ord($buffer[6]) &lt;&lt; 24)</span><br><span class="line">            | (ord($buffer[7]) &lt;&lt; 16)</span><br><span class="line">            | (ord($buffer[8]) &lt;&lt; 8)</span><br><span class="line">            | (ord($buffer[7]) &lt;&lt; 0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的代码，下面进行逐行解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$payload_length &#x3D; ord($buffer[1]) &amp; 0x7f;&#x2F;&#x2F;第二个字符的低7位</span><br></pre></td></tr></table></figure>
<p>读取第二个字节的低7位，也就是之前讨论的payload_length，0x7f转换为二进制就是01111111，ord($buffer[1]) 就是把第二个字符转换为对应的ASCII数值，两个进行与运算，就可以得到第二个字节的低7位对应的数值（与运算不熟悉的朋友，请先查看我在这篇博文前面给大家指定的链接），</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ($payload_length &gt;&#x3D; 0 &amp;&amp; $payload_length &lt; 125) &#123;</span><br><span class="line">        $this-&gt;current_message_length &#x3D; $payload_length;</span><br><span class="line">        $payload_type &#x3D; 1;</span><br><span class="line">        echo $payload_length . &quot;\n&quot;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>当payload_length的长度小于125的话，数据长度就等于片段长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ($payload_length &#x3D;&#x3D; 126) &#123;</span><br><span class="line">        $payload_type &#x3D; 2;</span><br><span class="line">        $this-&gt;current_message_length &#x3D; ((ord($buffer[2]) &amp; 0xff) &lt;&lt; 8) | (ord($buffer[3]) &amp; 0xff);</span><br><span class="line">        echo $this-&gt;current_message_length;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当payload_length的长度等于126的时候，就有些麻烦了，<strong>此时第3和第4个字节组合为一个无符号16位整数</strong>，还记得我们之前说的，网络字节序吗？高位字节在前，低位字节在后面，所以当我们读的时候，第3个字节就是高8位，第4个字节就是低8位，所以我们首先将高8位左移8位再和低8位做或运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$payload_type &#x3D; 3;</span><br><span class="line">$this-&gt;current_message_length &#x3D;</span><br><span class="line">    (ord($buffer[2]) &lt;&lt; 56)</span><br><span class="line">    | (ord($buffer[3]) &lt;&lt; 48)</span><br><span class="line">    | (ord($buffer[4]) &lt;&lt; 40)</span><br><span class="line">    | (ord($buffer[5]) &lt;&lt; 32)</span><br><span class="line">    | (ord($buffer[6]) &lt;&lt; 24)</span><br><span class="line">    | (ord($buffer[7]) &lt;&lt; 16)</span><br><span class="line">    | (ord($buffer[8]) &lt;&lt; 8)</span><br><span class="line">    | (ord($buffer[9]) &lt;&lt; 0);</span><br></pre></td></tr></table></figure>
<p>当payload_length的长度等于127的时候，<strong>此时的第3到第10位组合为一个无符号64位整数</strong>，所以最高的8位需要左移56位，后面的依次类推，低8位保持不动。</p>
<h4 id="解析mask-key"><a href="#解析mask-key" class="headerlink" title="解析mask key"></a>解析mask key</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;解析掩码，这个必须有的，掩码总共4个字节</span><br><span class="line">$mask_key_offset &#x3D; ($payload_type &#x3D;&#x3D; 1 ? 0 : ($payload_type &#x3D;&#x3D; 2 ? 2 : 8)) + 2;</span><br><span class="line">$this-&gt;mask_key &#x3D; substr($buffer, $mask_key_offset, 4);</span><br></pre></td></tr></table></figure>
<p>要找到maskey，首先必须找到它在当前片段的偏移，如果payload_length&lt;=125，那么偏移就是2，如果payload_length==126，那么偏移就是(2+2)=4，如果payload_length&gt;126，那么偏移就是（2+8）=10，同时mask key的大小为4个字节，所以找到了偏移和长度，mask key就可以获取到了。</p>
<h4 id="解密数据"><a href="#解密数据" class="headerlink" title="解密数据"></a>解密数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取加密的内容</span><br><span class="line">$real_message &#x3D; substr($buffer, $mask_key_offset + 4);</span><br><span class="line">$i &#x3D; 0;</span><br><span class="line">$parsed_ret &#x3D; &#39;&#39;;</span><br><span class="line">&#x2F;&#x2F;解析加密的数据</span><br><span class="line">while ($i &lt; strlen($real_message)) &#123;</span><br><span class="line">    $parsed_ret .&#x3D; chr((ord($real_message[$i]) ^ ord(($this-&gt;mask_key[$i % 4]))));</span><br><span class="line">    $i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解密数据的第一步就是要找到加密数据在当前片段中的偏移，很简单，这个值等于maskkey的偏移（上面已经求过了）+maskkey本身的长度4，那么怎么来解密数据呢？看上面的代码，就可以看出来，解密的过程其实就是遍历加密数据的每一个字符的ASCII值和数据（当前遍历的位置对4取模，得出的数据必定是0,1,2,3，将得出的数据找到maskkey对应位置的ASCII值）进行异或运算求得，这个算法是RFC6455规定的，全世界都是这样。</p>
<h2 id="返回数据给客户端"><a href="#返回数据给客户端" class="headerlink" title="返回数据给客户端"></a>返回数据给客户端</h2><p>从客户端发送到服务器和服务器传递给客户端的数据格式都遵循着同样的数据包格式，所以在我的实现中，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function echoContentToClient($client_socket, $content)</span><br><span class="line">&#123;</span><br><span class="line">    $len &#x3D; strlen($content);</span><br><span class="line">    &#x2F;&#x2F;第一个字节</span><br><span class="line">    $char_seq &#x3D; chr(0x80 | 1);</span><br><span class="line"></span><br><span class="line">    $b_2 &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;fill length</span><br><span class="line">    if ($len &gt; 0 &amp;&amp; $len &lt;&#x3D; 125) &#123;</span><br><span class="line">        $char_seq .&#x3D; chr(($b_2 | $len));</span><br><span class="line">    &#125; else if ($len &lt;&#x3D; 65535) &#123;</span><br><span class="line">        $char_seq .&#x3D; chr(($b_2 | 126));</span><br><span class="line">        $char_seq .&#x3D; (chr($len &gt;&gt; 8) . chr($len &amp; 0xff));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $char_seq .&#x3D; chr(($b_2 | 127));</span><br><span class="line">        $char_seq .&#x3D;</span><br><span class="line">            (chr($len &gt;&gt; 56)</span><br><span class="line">                . chr($len &gt;&gt; 48)</span><br><span class="line">                . chr($len &gt;&gt; 40)</span><br><span class="line">                . chr($len &gt;&gt; 32)</span><br><span class="line">                . chr($len &gt;&gt; 24)</span><br><span class="line">                . chr($len &gt;&gt; 16)</span><br><span class="line">                . chr($len &gt;&gt; 8)</span><br><span class="line">                . chr($len &gt;&gt; 0));</span><br><span class="line">    &#125;</span><br><span class="line">    $char_seq .&#x3D; $content;</span><br><span class="line">    $this-&gt;writeToSocket($client_socket, $char_seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了简便起见，第一个字节中FIN=1，opcode设置为1，接下来检查数据的长度，这部分内容和解析数据长度的步骤刚好相反，就不再分析了，如果你把之前的都看懂了，这里也应该没有问题，但是特别注意了，之前我们就已经提到过，服务器返回给客户端的数据，不能加密，所以mask必须设置为0，mask key的长度为0。</p>
<h2 id="运行实例"><a href="#运行实例" class="headerlink" title="运行实例"></a>运行实例</h2><p>就和本篇博文开篇所提到的，我写了一个简单的websocket实现，请一定要下载自己运行起来，光看是没有用的：<a target="_blank" rel="noopener" href="https://gitee.com/obamajs/php-websocket-base-implemention">php-websocket-base-implemention</a></p>
<p><img src="https://cdn.learnku.com/uploads/images/201911/14/39566/QI31dK1krp.png!large" alt="老司机带你实现Websocket协议"><br>如何运行websocket服务器</p>
<p><img src="https://cdn.learnku.com/uploads/images/201911/14/39566/uuKoGNPhoH.png!large" alt="老司机带你实现Websocket协议"></p>
<p>为了你可以看到实际运行的结果，请打开websocket.html文件，页面上出现这个就表示运行成功了。</p>
<p><img src="https://cdn.learnku.com/uploads/images/201911/14/39566/4NsDk0FZek.png!large" alt="老司机带你实现Websocket协议"></p>
<p>运行之前，请检查端口8080是否被占用，当然你可以修改websocket.html，改为其他的都可以，确保不被占用就可以了，如果你仍然无法运行，请联系我，如果你想看到其他的内容，也请修改websocket.html文件，然后重启服务器。</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>本篇博文的目的仅仅是为了向大家简要的介绍websocket最为核心的内容，还有一些内容没有讲到（剩下的不难，感兴趣的自己可以去实现），出于让大家更为直观的看清楚websocket的目的，代码中去掉了错误检查等内容，因此并不严谨，祝你学习愉快，下面有一个qq群，大家平时可以多学习下。</p>
<p><img src="https://cdn.learnku.com/uploads/images/201911/22/39566/JUOFyjuSgg.png!large" alt="老司机带你用 PHP 实现 Websocket 协议"></p>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/socket/" rel="tag"># socket</a>
              <a href="/tags/php/" rel="tag"># php</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/07/PHP-%E4%B8%8E-JavaScript-%E7%AB%AF%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/" rel="prev" title="PHP 与 JavaScript 端之间的加密解密">
      <i class="fa fa-chevron-left"></i> PHP 与 JavaScript 端之间的加密解密
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%86%99%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">我为什么会写这篇文章？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5"><span class="nav-number">2.</span> <span class="nav-text">文章链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">3.</span> <span class="nav-text">准备工作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#socket%E5%9F%BA%E7%A1%80"><span class="nav-number">3.1.</span> <span class="nav-text">socket基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">3.2.</span> <span class="nav-text">位运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E5%92%8C%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE"><span class="nav-number">3.3.</span> <span class="nav-text">二进制数据和文本数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E7%AB%AF%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%BA%8F%EF%BC%8C%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-number">3.4.</span> <span class="nav-text">大端序和小端序，网络字节序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="nav-number">4.</span> <span class="nav-text">协议的诞生</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">协议工作流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">数据包格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88"><span class="nav-number">7.</span> <span class="nav-text">协议流程概览</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Upgrade%E5%AD%97%E6%AE%B5"><span class="nav-number">7.0.1.</span> <span class="nav-text">Upgrade字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Connection"><span class="nav-number">7.0.2.</span> <span class="nav-text">Connection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sec-WebSocket-Key%E5%92%8CSec-WebSocket-Accept"><span class="nav-number">7.0.3.</span> <span class="nav-text">Sec-WebSocket-Key和Sec-WebSocket-Accept</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sec-WebSocket-Version"><span class="nav-number">7.0.4.</span> <span class="nav-text">Sec-WebSocket-Version</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sec-WebSocket-Protocol"><span class="nav-number">7.0.5.</span> <span class="nav-text">Sec-WebSocket-Protocol</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%A1%E6%89%8B%E9%98%B6%E6%AE%B5"><span class="nav-number">8.</span> <span class="nav-text">握手阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E5%8D%8F%E8%AE%AE"><span class="nav-number">9.</span> <span class="nav-text">分析数据协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FIN"><span class="nav-number">9.0.1.</span> <span class="nav-text">FIN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RSV1-RSV2-RSV3"><span class="nav-number">9.0.2.</span> <span class="nav-text">RSV1,RSV2,RSV3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#opcode"><span class="nav-number">9.0.3.</span> <span class="nav-text">opcode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MASK"><span class="nav-number">9.0.4.</span> <span class="nav-text">MASK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Payload-Length"><span class="nav-number">9.0.5.</span> <span class="nav-text">Payload Length</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mask-key"><span class="nav-number">9.0.6.</span> <span class="nav-text">Mask key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#payload-data"><span class="nav-number">9.0.7.</span> <span class="nav-text">payload data</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="nav-number">10.</span> <span class="nav-text">解析数据包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%95%B0%E6%8D%AE%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number">10.0.1.</span> <span class="nav-text">计算数据的长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90mask-key"><span class="nav-number">10.0.2.</span> <span class="nav-text">解析mask key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%AF%86%E6%95%B0%E6%8D%AE"><span class="nav-number">10.0.3.</span> <span class="nav-text">解密数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">11.</span> <span class="nav-text">返回数据给客户端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%AE%9E%E4%BE%8B"><span class="nav-number">12.</span> <span class="nav-text">运行实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA"><span class="nav-number">13.</span> <span class="nav-text">提示</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Airy"
      src="/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">Airy</p>
  <div class="site-description" itemprop="description">令行禁止</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Airy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
